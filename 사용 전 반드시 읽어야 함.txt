# 의료 영상 알고리즘 unet/unet++의 다크넷 구현을 위한 오픈 소스 코드
Leshan Wutong Zhu Wei(lswtzw)의 원격 오픈 소스 코드 기반, 주로 의료 이미지 알고리즘용 오픈 소스 코드(총 8MB 미만)


작동 환경 및 작동 조건:
win8/win10 ------(4GB 이상의 비디오 메모리가 있는 별도의 그래픽 카드를 가지고 있고 CUDA 개발 환경이 설치되어 있는 것이 가장 좋습니다. 설치되지 않은 경우 CPU 버전만 사용할 수 있음);
이 프로젝트는 opencv320-----을 설치해야 합니다.
마지막으로: opencv320 아래에 있는 opencv_world320.dll을 실행 디렉토리(darknet/build/darknet/x64/)에 복사하십시오.
     처음 사용 시 darknet_no_gpu.exe 버전(CPU 버전, 낮은 구성 요구 사항)을 실행하는 것이 좋습니다.


릴리즈 노트:
이 오픈 소스 프로젝트는 Windows 버전 AlexeyAB의 darknet 프레임워크를 기반으로 하므로 컴퓨터가 이미 AlexeyAB 버전으로 구성되어 있는 경우 다음을 바꾸십시오.
darknet.h, darknet.c, data.h, data.c, parser.c에 unet.h, unet.c를 추가하면 이 파일들로 충분합니다.
Darknet 프레임워크의 Windows 버전 설치 방법은 Baidu의 CSDN 기사 "win10에서 yolov3 구성", "창 아래에서 darknet 설치 및 구성" 등을 확인하십시오.
또한 이 오픈 소스 프로젝트는 네티즌의 블로그 게시물 "Semantic Segmentation of Pictures: Sunshine Glass"를 참조하고 이 오픈 소스 코드를 자신의 git 키 코드 및 구성을 기반으로 수정했으며 segnet 네트워크 모델을 사용합니다.


사용 지침:
darknet.exe는 내 컴퓨터에서 컴파일된 gpu 버전이기 때문에 컴퓨터에서 시작되지 않을 수 있으므로 소스 코드를 다시 컴파일해야 합니다.
빠르게 시작하려면 실행 파일 darknet_no_gpu.exe를 사용할 수 있습니다.
다운로드한 darknet 및 unet_data 디렉토리를 컴퓨터의 c: 루트 디렉토리에 복사하면 더 적은 경로를 구성할 수 있습니다.
테스트를 위해 먼저 unet_data 디렉토리에서 여러 배치 파일을 실행할 수 있습니다.

1. 파일 및 디렉토리 구성:
    1. darknet 디렉토리는 프로젝트의 소스 코드이며, build 서브디렉토리에서 vs2015 이상으로 .sln 프로젝트 파일을 엽니다.
    2. unet_data 디렉토리는 배치/구성 파일/이미지 세트/가중치 모델 파일을 호출하기 위한 기본 디렉토리이며 핵심은 data.txt입니다.
      이 파일은 다양한 경로에 대한 구성 파일이므로 해당 드라이브 문자를 수정하도록 주의하십시오!기본 초기값은 C 드라이브의 루트 디렉토리에 있습니다.
      위의 내용은 기존 다크넷 프레임워크의 데이터 설정 파일과 유사하며 사용법이 약간 변경되었습니다.
    3. 색상 디렉토리에는 색상 교육 이미지와 해당 구성 파일이 포함되어 있습니다.
    4. 백업 디렉토리는 일반적으로 훈련된 모델 파일을 저장하는 데 사용됩니다.

2. 네트워크 모델 구성:
    두 개의 텍스트 파일 unet_cfg.txt/unet_cfg++.txt는 네트워크 모델 구성 파일입니다.
    (다크넷 형식의 cfg와 정확히 동일), 참고: UTF-8 인코딩으로 저장하지 마십시오(때로는 실수할 수 있음).
    Windows 메모장의 기본 ANSI 인코딩을 사용하여 저장합니다.(Windows 캐리지 리턴 및 줄 바꿈 모드)
    설정 파일은 segnet과 같은 다양한 네트워크 모델을 자유롭게 사용할 수 있으며, 이것을 darknet의 cfg 디렉토리에 넣습니다.

3. 데이터 보강 정보:
    라벨(마스킹된 바이너리 이미지)과 이미지는 파일명에 따라 1:1 대응하기 때문에 번역이나 압출 등의 변경이 있을 경우,
    두 가지를 동시에 수행해야 하므로 다른 도구 소프트웨어나 프로그램으로 구현하는 다른 방법을 찾아야 하며 결과 그래프는 교육 템플릿에 직접 추가됩니다.

4. 교육 종료 시간:
    저자의 경험에 따르면 avg_loss의 값은 훈련이 100 미만이면 거의 중지하기에 충분합니다.
    간단히 말해서 내 GT750 그래픽 카드 4GB 비디오 메모리, 10개의 템플릿이 4시간 넘게 걸렸고, unet++의 훈련 시간이 unet의 훈련 시간보다 훨씬 깁니다.
    교육이 24시간 동안 작동하지 않으면 일반적으로 템플릿 이미지에 문제가 있고 충돌하는 템플릿이 있습니다.
    저자의 경험에 따르면 GPU 인식 속도는 일반적으로 2초 이내이며 이미지의 크기와 네트워크의 복잡도에 따라 다릅니다.
    훈련 시작 후 nvidia-smi를 사용하여 비디오 메모리 사용량을 확인할 수 있으며, 메모리 사용량이 더 많을 경우 cfg의 [net] 배치 값이나 이미지의 너비와 높이를 늘릴 수 있습니다.

5. 인터페이스 호출:
    C#과 JAVA의 약한 결합 호출을 용이하게 하기 위해 일회성 로딩 모델과 다중 주문형 식별을 위한 호출 인터페이스를 제공합니다. 프로젝트에 포함된 문서를 참조하십시오.